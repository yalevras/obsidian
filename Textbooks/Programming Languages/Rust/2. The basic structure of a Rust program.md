 **2.1 Compiling**
Rust compiler: rustc, centered around Cargo, a build system which acts as a frontend for compiling code and managing external libraries called **crates**. It combines the roles of make, cmake, and apt.
```
cargo new my_project
cd my_project

cargo build

cargo run
```

**2.2 Basic Program Structure**

Modules: logical units of code (public/private)
Functions: same old
Type Defs: custom data structures using struct, enum, or type aliases (type)
Constants and Statics: immutable (unable to be changed) values known at compile time or globally accessible data
use Statements: Import items (functions, types, etc.) from other modules or external crates into the current scope.

We use {} for code blocks. Rust automatically frees associated memory with local variables (according to RAII - Resource Acquisition Is Initialization, which is Rust's resource management). Rust does not require forward declaration of functions or types, you can call a function defined later in the file.

**2.3 The *main* Function: The Entry Point**

```
fn main() {
	println!("Hello, world!");
}
```
*println!* prints a new line at the end
*print!* does not

to print variables

```
let local_variable = "argument";
println!("this is an {local_variable}!");
```

Rust's main function returns the unit type (), indicating success, this can be changed later.

**2.4 Variables: Immutability by Default**
```
let variable_name: OptionalType = value;
```
Variables must be initialized before their first usage. Variables are immutable by default.

Example:
```
fn main() {
	let x: i32 = 5;
	// x = 6; // This line would cause a compile-time error!
	println!("The value of x is: {}", x);
}
```

To enable mutability, we can use the mut keyword.
```
fn main() {
	let mut x = 5;
	println("The initial value of x is: {}", x);
	x = 6;
	println!("The new value of x is: {}", x);
}
```

In Rust, variables are automatically like const in C.

**2.5 Data Types and Annotations**

Integers:
- signed
	- i8, i16, i32, i64, i128, isize (4 bytes on a 32 bit target, 8 bytes on a 64 bit target)
- unsigned
	- u8, u16, u32, u64, u128, usize
isize and usize are like ptrdiff_t and size_t in C
Floating-Point: f32 (singled-precision), and f64 (double-precision)
	Single precision uses 32 bits of memory, 1 for sign, 8 for exponent and 23 for mantissa
	Double precision uses 64 bits of memory, 1 for sign, 11 for exponent and 52 for mantissa
Boolean: bool (can be true or false)
Character: char (Unicode scalar value (4 bytes), contrasts with C's char which is usually a single byte)

References:
For references and pointers, Rust uses & for immutable access and &mut for mutable access. * can be used to access (dereference) the value behind a reference.
```
fn inc(i: &mut i32) {
	*i += 1;
}

fn main() {
	let mut v = 0;
	inc(&mut v);
	println!("{v}"); // 1
	let r = &mut v;
	inc(r);
	println!("{}", *r); // 2
}
```

Type Inference:
The compiler often deduces the type based on context:
```
fn main() {
	let answer = 42; // Type i32 inferred by default for integers
	let pi = 3.14159; // Type f64 inferred by default for floats
	let active = true; // Type bool inferred
}
```

Used a colon after the let and variable name if the compiler needs guidance or if you want a non-default type
```
let temperature: f32 = 21.5; // Explicitly typed as a 32-bit float
```

**2.6 Constants and Static Variables**

**Constants**
Constants are values known at compile time. Must be annotated with a type. Naming convention is SCREAMING_SNAKE_CASE.
```
const SECONDS_IN_MINUTE: u32 = 60;
const PI: f64 = 3.1415926535;

fn main() {
	println!("One minute has {} seconds.", SECONDS_IN_MINUTE);
}
```
**Static Variables**
Represent values that have a fixed memory location ('static lifetime) throughout the program's execution. Initialized once at the start of the program. They must have an explicit type annotation. Naming convention is the same as constants.
```
static APP_NAME: &str = "Rust Explorer"; // A static string literal

fn main() {
	println!("Welcome to {}!", APP_NAME);
}
```

Rust's const is similar to C's #define but also still const variables in C, while Rust's static is closed to C's global or file-scope static variables regarding lifetime and memory location.

**2.7 Functions and Methods**
